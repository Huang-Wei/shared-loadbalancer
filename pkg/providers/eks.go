/*
Copyright 2018 The Shared LoadBalancer Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package providers

import (
	"errors"
	"fmt"
	"strings"

	kubeconv1alpha1 "github.com/Huang-Wei/shared-loadbalancer/pkg/apis/kubecon/v1alpha1"
	"github.com/aws/aws-sdk-go/aws"
	"github.com/aws/aws-sdk-go/aws/endpoints"
	"github.com/aws/aws-sdk-go/aws/session"
	"github.com/aws/aws-sdk-go/service/ec2"
	"github.com/aws/aws-sdk-go/service/elb"
	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/types"
)

// Notes:
// - don't use elbv2 package as the EKS LB service generated by default is not elbv2 instance

// Refs:
// https://docs.aws.amazon.com/sdk-for-go/api/service/elb/#New
// https://docs.aws.amazon.com/sdk-for-go/api/service/elb/#example_ELB_DescribeLoadBalancers_shared00
// https://docs.aws.amazon.com/sdk-for-go/api/service/ec2/#EC2.AuthorizeSecurityGroupIngress

// for a EKS loadbalancer service, the corresponding ELS name is first section of hostname
// e.g. a150664e6b12311e883b3061edd716de-2116084625.us-west-2.elb.amazonaws.com
// the ELS name is a150664e6b12311e883b3061edd716de

// EKS stands for Elastic(Amazon) Kubernetes Service
type EKS struct {
	elbClient *elb.ELB
	ec2Client *ec2.EC2

	// key is namespacedName of a LB Serivce, val is the service
	cacheMap map[types.NamespacedName]*corev1.Service
	cacheELB map[types.NamespacedName]*elb.LoadBalancerDescription

	// cr to LB is 1:1 mapping
	crToLB map[types.NamespacedName]types.NamespacedName
	// lb to CRD is 1:N mapping
	lbToCRs map[types.NamespacedName]nameSet

	capacityPerLB int
}

var _ LBProvider = &EKS{}

func newEKSProvider() *EKS {
	// TODO(Huang-Wei): make aws credentials and regionID configurable
	sess := session.Must(session.NewSession(&aws.Config{
		Region: aws.String(endpoints.UsWest2RegionID),
	}))
	return &EKS{
		elbClient:     elb.New(sess),
		ec2Client:     ec2.New(sess),
		cacheMap:      make(map[types.NamespacedName]*corev1.Service),
		cacheELB:      make(map[types.NamespacedName]*elb.LoadBalancerDescription),
		crToLB:        make(map[types.NamespacedName]types.NamespacedName),
		lbToCRs:       make(map[types.NamespacedName]nameSet),
		capacityPerLB: 2,
	}
}

func (e *EKS) GetCapacityPerLB() int {
	return e.capacityPerLB
}

func (e *EKS) UpdateCache(key types.NamespacedName, lbSvc *corev1.Service) {
	if lbSvc == nil {
		delete(e.cacheMap, key)
		delete(e.cacheELB, key)
	} else {
		e.cacheMap[key] = lbSvc
		// handle ELB stuff
		if len(lbSvc.Status.LoadBalancer.Ingress) == 1 {
			hostname := lbSvc.Status.LoadBalancer.Ingress[0].Hostname
			elbName := strings.Split(strings.Split(hostname, ".")[0], "-")[0]
			if result, err := e.queryELB(elbName); err != nil {
				log.WithName("eks").Error(err, "cannot query ELB", "key", key, "elbName", elbName)
			} else {
				log.WithName("eks").Info("A LB Svc is updated", "key", key, "elbName", elbName)
				e.cacheELB[key] = result
			}
		}
	}
}

func (e *EKS) NewService(sharedLB *kubeconv1alpha1.SharedLB) *corev1.Service {
	return &corev1.Service{
		ObjectMeta: metav1.ObjectMeta{
			Name:      sharedLB.Name + svcPostfix,
			Namespace: sharedLB.Namespace,
		},
		Spec: corev1.ServiceSpec{
			// TODO(Huang-Wei): NodePort is best solution we can come up with so far
			Type:     corev1.ServiceTypeNodePort,
			Ports:    sharedLB.Spec.Ports,
			Selector: sharedLB.Spec.Selector,
		},
	}
}

func (e *EKS) NewLBService() *corev1.Service {
	return &corev1.Service{
		ObjectMeta: metav1.ObjectMeta{
			Name:      "lb-" + RandStringRunes(8),
			Namespace: namespace,
			Labels:    map[string]string{"lb-template": ""},
		},
		Spec: corev1.ServiceSpec{
			Ports: []corev1.ServicePort{
				{
					Name:     "tcp",
					Protocol: corev1.ProtocolTCP,
					Port:     33333,
				},
				// EKS doesn't support UDP, so don't bother
				// {
				// 	Name:     "UDP",
				// 	Protocol: corev1.ProtocolUDP,
				// 	Port:     33333,
				// },
			},
			Type: corev1.ServiceTypeLoadBalancer,
		},
	}
}

func (e *EKS) GetAvailabelLB() *corev1.Service {
	for lbKey, lbSvc := range e.cacheMap {
		if len(e.lbToCRs[lbKey]) < e.capacityPerLB {
			return lbSvc
		}
	}

	return nil
}

func (e *EKS) AssociateLB(crName, lbName types.NamespacedName, clusterSvc *corev1.Service) error {
	// a) create LoadBalancer listener (create-load-balancer-listeners)
	// b) create inbound rules to security group (authorize-security-group-ingress)
	if elbDesc := e.cacheELB[lbName]; elbDesc != nil {
		if err := e.createListeners(clusterSvc, elbDesc); err != nil {
			return err
		}
		if err := e.createInboundRules(clusterSvc, elbDesc); err != nil {
			return err
		}
	}

	// c) update internal cache
	_, ok := e.lbToCRs[lbName]
	if !ok {
		e.lbToCRs[lbName] = make(nameSet)
	}
	e.lbToCRs[lbName][crName] = struct{}{}
	e.crToLB[crName] = lbName
	log.WithName("eks").Info("AssociateLB", "cr", crName, "lb", lbName)
	return nil
}

func (e *EKS) DeassociateLB(crName types.NamespacedName) error {
	lbName, ok := e.crToLB[crName]
	if !ok {
		return nil
	}

	// a) remove LoadBalancer listener (delete-load-balancer-listeners)
	// b) remove inbound rules from security group (revoke-security-group-ingress)
	if elbDesc := e.cacheELB[lbName]; elbDesc != nil {
		// TODO(Huang-Wei): Oct 25, 2018
	}

	// c) update cache
	delete(e.crToLB, crName)
	delete(e.lbToCRs[lbName], crName)
	log.WithName("eks").Info("DeassociateLB", "cr", crName, "lb", lbName)
	return nil
}

func (e *EKS) UpdateService(svc, lb *corev1.Service) (bool, bool) {
	portUpdated := updatePort(svc, lb)
	return portUpdated, false
}

func (e *EKS) queryELB(elbName string) (*elb.LoadBalancerDescription, error) {
	if elbName == "" {
		return nil, errors.New("elbName cannot be empty")
	}
	input := &elb.DescribeLoadBalancersInput{
		LoadBalancerNames: []*string{
			aws.String(elbName),
		},
	}
	result, err := e.elbClient.DescribeLoadBalancers(input)
	if err != nil {
		return nil, err
	}
	if len(result.LoadBalancerDescriptions) != 1 {
		return nil, fmt.Errorf("got %d elb.LoadBalancerDescription, but expected 1", len(result.LoadBalancerDescriptions))
	}
	return result.LoadBalancerDescriptions[0], nil
}

func (e *EKS) createListeners(clusterSvc *corev1.Service, elbDesc *elb.LoadBalancerDescription) error {
	if clusterSvc == nil || elbDesc == nil {
		return errors.New("clusterSvc or elbDesc is nil")
	}
	listeners := make([]*elb.Listener, len(clusterSvc.Spec.Ports))
	for i, p := range clusterSvc.Spec.Ports {
		lowercasedProtocol := strings.ToLower(string(p.Protocol))
		listener := elb.Listener{
			InstancePort:     aws.Int64(int64(p.NodePort)),
			InstanceProtocol: aws.String(lowercasedProtocol),
			LoadBalancerPort: aws.Int64(int64(p.Port)),
			Protocol:         aws.String(lowercasedProtocol),
			// TODO(Huang-Wei): InstanceProtocol vs. Protocol?
		}
		listeners[i] = &listener
	}
	input := &elb.CreateLoadBalancerListenersInput{
		Listeners:        listeners,
		LoadBalancerName: elbDesc.LoadBalancerName,
	}
	_, err := e.elbClient.CreateLoadBalancerListeners(input)
	return err
}

func (e *EKS) createInboundRules(clusterSvc *corev1.Service, elbDesc *elb.LoadBalancerDescription) error {
	if clusterSvc == nil || elbDesc == nil {
		return errors.New("clusterSvc or elbDesc is nil")
	}

	sgStrs := elbDesc.SecurityGroups
	if len(sgStrs) == 0 {
		return errors.New("no security group is attached to the ELB")
	}

	ipPermissions := make([]*ec2.IpPermission, len(clusterSvc.Spec.Ports))
	for i, p := range clusterSvc.Spec.Ports {
		lowercasedProtocol := strings.ToLower(string(p.Protocol))
		permission := ec2.IpPermission{
			FromPort:   aws.Int64(int64(p.Port)),
			IpProtocol: aws.String(lowercasedProtocol),
			IpRanges: []*ec2.IpRange{
				{
					CidrIp:      aws.String("0.0.0.0/0"),
					Description: aws.String("Generated by shared-loadblancer"),
				},
			},
			ToPort: aws.Int64(int64(p.Port)),
		}
		ipPermissions[i] = &permission
	}

	input := &ec2.AuthorizeSecurityGroupIngressInput{
		// pick up the first security group
		GroupId:       sgStrs[0],
		IpPermissions: ipPermissions,
	}
	_, err := e.ec2Client.AuthorizeSecurityGroupIngress(input)
	return err
}
