/*
Copyright 2018 The Shared LoadBalancer Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package providers

import (
	"errors"
	"fmt"
	"strings"

	kubeconv1alpha1 "github.com/Huang-Wei/shared-loadbalancer/pkg/apis/kubecon/v1alpha1"
	"github.com/aws/aws-sdk-go/aws"
	"github.com/aws/aws-sdk-go/aws/endpoints"
	"github.com/aws/aws-sdk-go/aws/session"
	"github.com/aws/aws-sdk-go/service/ec2"
	"github.com/aws/aws-sdk-go/service/elb"
	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/types"
)

// Notes:
// - don't use elbv2 package as the EKS LB service generated by default is not elbv2 instance

// Refs:
// https://docs.aws.amazon.com/sdk-for-go/api/service/elb/#New
// https://docs.aws.amazon.com/sdk-for-go/api/service/elb/#example_ELB_DescribeLoadBalancers_shared00
// https://docs.aws.amazon.com/sdk-for-go/api/service/ec2/#EC2.AuthorizeSecurityGroupIngress

// for a EKS loadbalancer service, the corresponding ELS name is first section of hostname
// e.g. a150664e6b12311e883b3061edd716de-2116084625.us-west-2.elb.amazonaws.com
// the ELS name is a150664e6b12311e883b3061edd716de

// EKS stands for Elastic(Amazon) Kubernetes Service
type EKS struct {
	elbClient *elb.ELB
	ec2Client *ec2.EC2

	// key is namespacedName of a LB Serivce, val is the service
	cacheMap map[types.NamespacedName]*corev1.Service
	cacheELB map[types.NamespacedName]*elb.LoadBalancerDescription

	// cr to LB is 1:1 mapping
	crToLB map[types.NamespacedName]types.NamespacedName
	// lb to CRD is 1:N mapping
	lbToCRs map[types.NamespacedName]nameSet

	capacityPerLB int
}

var _ LBProvider = &EKS{}

func newEKSProvider() *EKS {
	// TODO(Huang-Wei): make aws credentials and regionID configurable
	sess := session.Must(session.NewSession(&aws.Config{
		Region: aws.String(endpoints.UsWest2RegionID),
	}))
	return &EKS{
		elbClient:     elb.New(sess),
		ec2Client:     ec2.New(sess),
		cacheMap:      make(map[types.NamespacedName]*corev1.Service),
		cacheELB:      make(map[types.NamespacedName]*elb.LoadBalancerDescription),
		crToLB:        make(map[types.NamespacedName]types.NamespacedName),
		lbToCRs:       make(map[types.NamespacedName]nameSet),
		capacityPerLB: capacity,
	}
}

func (e *EKS) GetCapacityPerLB() int {
	return e.capacityPerLB
}

func (e *EKS) UpdateCache(key types.NamespacedName, lbSvc *corev1.Service) {
	if lbSvc == nil {
		delete(e.cacheMap, key)
		delete(e.cacheELB, key)
	} else {
		e.cacheMap[key] = lbSvc
		// handle ELB stuff
		if len(lbSvc.Status.LoadBalancer.Ingress) == 1 {
			hostname := lbSvc.Status.LoadBalancer.Ingress[0].Hostname
			elbName := strings.Split(strings.Split(hostname, ".")[0], "-")[0]
			if result, err := e.queryELB(elbName); err != nil {
				log.WithName("eks").Error(err, "cannot query ELB", "key", key, "elbName", elbName)
			} else {
				log.WithName("eks").Info("ELB obj is updated in local cache", "key", key, "elbName", elbName)
				e.cacheELB[key] = result
			}
		}
	}
}

func (e *EKS) NewService(sharedLB *kubeconv1alpha1.SharedLB) *corev1.Service {
	return &corev1.Service{
		ObjectMeta: metav1.ObjectMeta{
			Name:      sharedLB.Name + svcPostfix,
			Namespace: sharedLB.Namespace,
		},
		Spec: corev1.ServiceSpec{
			// TODO(Huang-Wei): NodePort is the solution we can come up with so far
			Type:     corev1.ServiceTypeNodePort,
			Ports:    sharedLB.Spec.Ports,
			Selector: sharedLB.Spec.Selector,
		},
	}
}

func (e *EKS) NewLBService() *corev1.Service {
	return &corev1.Service{
		ObjectMeta: metav1.ObjectMeta{
			Name:      "lb-" + RandStringRunes(8),
			Namespace: namespace,
			Labels:    map[string]string{"lb-template": ""},
		},
		Spec: corev1.ServiceSpec{
			Type:     corev1.ServiceTypeLoadBalancer,
			Selector: map[string]string{"app": "lb-placeholder"},
			Ports: []corev1.ServicePort{
				{
					Name:     "tcp",
					Protocol: corev1.ProtocolTCP,
					Port:     33333,
				},
				// EKS doesn't support UDP, so don't bother
				// {
				// 	Name:     "UDP",
				// 	Protocol: corev1.ProtocolUDP,
				// 	Port:     33333,
				// },
			},
		},
	}
}

func (e *EKS) GetAvailabelLB() *corev1.Service {
	for lbKey, lbSvc := range e.cacheMap {
		if len(e.lbToCRs[lbKey]) < e.capacityPerLB {
			return lbSvc
		}
	}

	return nil
}

func (e *EKS) AssociateLB(crName, lbName types.NamespacedName, clusterSvc *corev1.Service) error {
	// a) create LoadBalancer listener (create-load-balancer-listeners)
	// b) create inbound rules to security group (authorize-security-group-ingress)
	if clusterSvc != nil {
		if elbDesc := e.cacheELB[lbName]; elbDesc != nil {
			needRun, err := e.createListeners(clusterSvc, elbDesc)
			if err != nil {
				return err
			}
			if !needRun {
				return nil
			}
			if err := e.createInboundRules(clusterSvc, elbDesc); err != nil {
				return err
			}
		} else {
			return errors.New("ELB not exist yet")
		}
	}

	// c) update internal cache
	// following code might be called multiple times, but shouldn't impact
	// performance a lot as all of them are O(1) operation
	_, ok := e.lbToCRs[lbName]
	if !ok {
		e.lbToCRs[lbName] = make(nameSet)
	}
	e.lbToCRs[lbName][crName] = struct{}{}
	e.crToLB[crName] = lbName
	log.WithName("eks").Info("AssociateLB", "cr", crName, "lb", lbName)
	return nil
}

// DeassociateLB is called by EKS finalizer to clean listeners
// and inbound rules of security group
func (e *EKS) DeassociateLB(crName types.NamespacedName) error {
	lbName, ok := e.crToLB[crName]
	if !ok {
		return nil
	}

	// a) remove LoadBalancer listener (delete-load-balancer-listeners)
	// b) remove inbound rules from security group (revoke-security-group-ingress)
	if elbDesc := e.cacheELB[lbName]; elbDesc != nil {
		// TODO: we can't abtaint the clusterSvc, which has been deleted
		// if err := e.removeListeners(clusterSvc, elbDesc); err != nil {
		// 	return err
		// }
		// if err := e.removeInboundRules(clusterSvc, elbDesc); err != nil {
		// 	return err
		// }
	}

	// c) update internal cache
	delete(e.crToLB, crName)
	delete(e.lbToCRs[lbName], crName)
	log.WithName("eks").Info("DeassociateLB", "cr", crName, "lb", lbName)
	return nil
}

func (e *EKS) UpdateService(svc, lb *corev1.Service) (bool, bool) {
	portUpdated := updatePort(svc, lb)
	// don't need to update externalIP
	return portUpdated, false
}

func (e *EKS) queryELB(elbName string) (*elb.LoadBalancerDescription, error) {
	if elbName == "" {
		return nil, errors.New("elbName cannot be empty")
	}
	input := &elb.DescribeLoadBalancersInput{
		LoadBalancerNames: []*string{
			aws.String(elbName),
		},
	}
	result, err := e.elbClient.DescribeLoadBalancers(input)
	if err != nil {
		return nil, err
	}
	if len(result.LoadBalancerDescriptions) != 1 {
		return nil, fmt.Errorf("got %d elb.LoadBalancerDescription, but expected 1", len(result.LoadBalancerDescriptions))
	}
	return result.LoadBalancerDescriptions[0], nil
}

func (e *EKS) createListeners(clusterSvc *corev1.Service, elbDesc *elb.LoadBalancerDescription) (bool, error) {
	if clusterSvc == nil || elbDesc == nil {
		return false, errors.New("clusterSvc or elbDesc is nil")
	}
	listeners := make([]*elb.Listener, 0)
	for _, p := range clusterSvc.Spec.Ports {
		lowercasedProtocol := strings.ToLower(string(p.Protocol))
		listener := elb.Listener{
			InstancePort:     aws.Int64(int64(p.NodePort)),
			InstanceProtocol: aws.String(lowercasedProtocol),
			LoadBalancerPort: aws.Int64(int64(p.Port)),
			Protocol:         aws.String(lowercasedProtocol),
			// TODO(Huang-Wei): InstanceProtocol vs. Protocol?
		}
		// check if it exists in elbDesc
		if isListenerExisted(listener, elbDesc.ListenerDescriptions) {
			continue
		}
		listeners = append(listeners, &listener)
	}
	if len(listeners) == 0 {
		return false, nil
	}

	input := &elb.CreateLoadBalancerListenersInput{
		Listeners:        listeners,
		LoadBalancerName: elbDesc.LoadBalancerName,
	}
	_, err := e.elbClient.CreateLoadBalancerListeners(input)
	return true, err
}

func isListenerExisted(l elb.Listener, listenerDescs []*elb.ListenerDescription) bool {
	for _, desc := range listenerDescs {
		e := desc.Listener
		if *l.InstancePort == *e.InstancePort && *l.InstanceProtocol == *e.InstanceProtocol &&
			*l.LoadBalancerPort == *e.LoadBalancerPort && *l.Protocol == *e.Protocol {
			return true
		}
	}
	return false
}

func (e *EKS) createInboundRules(clusterSvc *corev1.Service, elbDesc *elb.LoadBalancerDescription) error {
	if clusterSvc == nil || elbDesc == nil {
		return errors.New("clusterSvc or elbDesc is nil")
	}

	sgStrs := elbDesc.SecurityGroups
	if len(sgStrs) == 0 {
		return errors.New("no security group is attached to the ELB")
	}

	ipPermissions := make([]*ec2.IpPermission, 0)
	for _, p := range clusterSvc.Spec.Ports {
		lowercasedProtocol := strings.ToLower(string(p.Protocol))
		permission := ec2.IpPermission{
			FromPort:   aws.Int64(int64(p.Port)),
			IpProtocol: aws.String(lowercasedProtocol),
			IpRanges: []*ec2.IpRange{
				{
					CidrIp:      aws.String("0.0.0.0/0"),
					Description: aws.String("Generated by shared-loadblancer"),
				},
			},
			ToPort: aws.Int64(int64(p.Port)),
		}
		ipPermissions = append(ipPermissions, &permission)
	}
	if len(ipPermissions) == 0 {
		return nil
	}

	input := &ec2.AuthorizeSecurityGroupIngressInput{
		// pick up the first security group
		// TODO(Huang-Wei): what if multiple security groups are found
		GroupId:       sgStrs[0],
		IpPermissions: ipPermissions,
	}
	_, err := e.ec2Client.AuthorizeSecurityGroupIngress(input)
	return err
}
